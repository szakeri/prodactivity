# -*- python -*-
# ex: set syntax=python:

import os
import re

from buildbot.plugins import *

from bbot_extras import latent_docker
from bbot_extras import latent_marathon

# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.
c = BuildmasterConfig = {}

projects = []
build_factories = {}

# - pipeline = a buildfactory that consists of a series of TriggerSteps
# - stage = a Triggerable scheduler
# - scheduler = builder(s) [+ changefilter]
# - builder = buildfactory + buildworker(s)
# - buildfactory = series of buildsteps

####### PROJECTS

projects = [
    {
        'name': "velcro.controller",
        'repo': "git@bldr-git.int.lineratesystems.com:velcro/lwp-controller.git",
        # - run at 12:15 AM
        'nightly': {'hour': 0, 'minute': 15, 'branch': "master"},
        'pipelines': [
            {
                'name': "systest",
                'stages': [
                    "setprop orchestration marathon",
                    "functest",
                    "scaletest",
                    "perftest",
#                    "setprop orchestration k8s",
#                    "functest",
#                    "scaletest",
#                    "perftest",
                ],
            },
        ]
    },
    {
        'name': "velcro.f5mlb",
        'repo': "git@bldr-git.int.lineratesystems.com:velcro/f5-marathon-lb.git",
        # - run at 1:30 AM
        'nightly': {'hour': 1, 'minute': 30, 'branch': "master"},
        'pipelines': [
            {
                'name': "systest",
                'stages': [
                    "setprop orchestration marathon",
                    "functest",
                    "scaletest",
#                    "setprop orchestration k8s",
#                    "functest",
#                    "scaletest",
                ],
            },
        ]
    },
    {
        'name': "velcro.proxy",
        'repo': "git@bldr-git.int.lineratesystems.com:velcro/lightweight-proxy.git",
        # - run at 2:15 AM
        'nightly': {'hour': 2, 'minute': 15, 'branch': "master"},
        'pipelines': [
            {
                'name': "systest",
                'stages': [
                    "setprop orchestration marathon",
                    "functest",
#                    "setprop orchestration k8s",
#                    "functest",
                ],
            },
        ]
    },
    {
        'name': "openstack.agent",
        'repo': "https://github.com/F5Networks/f5-openstack-agent.git",
        # - run at 3:00 AM
        'nightly': {'hour': 3, 'minute': 0, 'branch': "liberty"},
        'pipelines': [
            {
                'name': "functest",
                'stages': [ "functest" ]
            },
        ]
    },
    {
        'name': "openstack.lbaasv2-driver",
        'repo': "https://github.com/F5Networks/f5-openstack-lbaasv2-driver.git",
        # - run at 3:45 AM
        'nightly': {'hour': 3, 'minute': 45, 'branch': "liberty"},
        'pipelines': [
            {
                'name': "functest",
                'stages': [ "functest" ]
            },
        ]
    },
]


####### BUILDSLAVES

# The 'slaves' list defines the set of recognized buildworkers. Each element is
# a BuildSlave object, specifying a unique worker name and password.  The same
# worker name and password must be configured on the worker.

c['slaves'] = []

default_workers = []
pool_size = int(os.environ['BBOT_WORKER_POOL_SIZE'])

ext_config_dir = "%s/config" % os.environ['NFS_BASEDIR']
ext_log_dir = "%s/bbot-worker" % os.environ['NFS_BASEDIR']
ext_results_dir = os.environ['RESULTS_BASEDIR']

img_name = os.environ['BBOT_WORKER_IMG'].split("/")[-1]
# - remove "bbot-worker-" prefix
img_name = img_name.replace("bbot-worker-", "")
# - remove trailing tag
img_name = img_name.split(":")[0]

if os.environ.get('DOCKER_URL'):
    for i in range(1, pool_size + 1):
        worker_name = "bbot-latent-docker-%s-%d" % (img_name, i)
        worker = latent_docker.LatentDockerWorker(
            name=worker_name,
            password=os.environ['BBOT_WORKER_PASS'],
            docker_url=os.environ['DOCKER_URL'],
            img=os.environ['BBOT_WORKER_IMG'],
            env={
                'GITLAB_HOST': os.environ['GITLAB_HOST'],
                'GITLAB_SSH_PORT': os.environ['GITLAB_SSH_PORT'],
                'BBOT_HOST': os.environ['BBOT_HOST'],
                'BBOT_PB_PORT': os.environ['BBOT_PB_PORT'],
                'BBOT_WORKER_NAME': worker_name,
                'BBOT_WORKER_PASS': os.environ['BBOT_WORKER_PASS']
            },
            volumes={
                '/etc/localtime': "/etc/localtime",
                ext_config_dir: "/home/buildbot/bbot-config",
                ext_log_dir: "/home/buildbot/bbot-worker",
                ext_results_dir: "/home/buildbot/test_results"
            },
            # - only allow one job per latent worker
            max_builds=1,
            # - remove the latent worker immediately after its work is done
            build_wait_timeout=0,
        )
        c['slaves'].append(worker)
        default_workers.append(worker_name)

if os.environ.get('MARATHON_URL'):
    for i in range(1, pool_size + 1):
        worker_name = "bbot-latent-marathon-%s-%d" % (img_name, i)
        worker = latent_marathon.LatentMarathonWorker(
            name=worker_name,
            password=os.environ['BBOT_WORKER_PASS'],
            marathon_url=os.environ['MARATHON_URL'],
            img=os.environ['BBOT_WORKER_IMG'],
            cpus=os.environ['BBOT_MARATHON_WORKER_CPUS'],
            mem=os.environ['BBOT_MARATHON_WORKER_MEM'],
            env={
                'GITLAB_HOST': os.environ['GITLAB_HOST'],
                'GITLAB_SSH_PORT': os.environ['GITLAB_SSH_PORT'],
                'BBOT_HOST': os.environ['BBOT_HOST'],
                'BBOT_PB_PORT': os.environ['BBOT_PB_PORT'],
                'BBOT_WORKER_NAME': worker_name,
                'BBOT_WORKER_PASS': os.environ['BBOT_WORKER_PASS']
            },
            volumes={
                '/etc/localtime': "/etc/localtime",
                ext_config_dir: "/home/buildbot/bbot-config",
                ext_log_dir: "/home/buildbot/bbot-worker",
                ext_results_dir: "/home/buildbot/test_results"
            },
            force_pull_img=True,
            # - only allow one job per latent worker
            max_builds=1,
            # - remove the latent worker immediately after its work is done
            build_wait_timeout=0,
        )
        c['slaves'].append(worker)
        default_workers.append(worker_name)

# 'protocols' contains information about protocols which master will use for
# communicating with workers.
# You must define at least 'port' option that workers could connect to your master
# with this protocol.
# 'port' must match the value configured into the buildworkers (with their
# --master option)
c['protocols'] = {'pb': {'port': os.environ['BBOT_PB_PORT']}}

####### CHANGESOURCES

# the 'change_source' setting tells the buildmaster how it should find out
# about source code changes.  We don't define any change sources here because
# we plan to use "change hooks" to connect our eligible git repos to buildbot.

c['change_source'] = []

####### SCHEDULERS

# Configure the Schedulers, which decide how to react to incoming changes.

c['schedulers'] = []

def get_pipeline_builder_name(project, pipeline, idx):
    return "%02d-%s.%s" % (idx, project, pipeline)

pipeline_idx = 0
for proj in projects:
    for pipeline in proj['pipelines']:
        pipeline_idx += 1
        bldr_name = get_pipeline_builder_name(
            proj['name'], pipeline['name'], pipeline_idx
        )
        nightly = schedulers.Nightly(
            name="%s.%s/nightly/%s" % (
                proj['name'], pipeline['name'], proj['nightly']['branch']
            ),
            branch=proj['nightly']['branch'],
            codebases = {
                proj['name']: {
                    'repository': proj['repo'],
                    'branch': proj['nightly']['branch']
                }
            },
            builderNames=[bldr_name],
            # - run every night (note that '0' is Monday)
            dayOfWeek=range(7),
            hour=proj['nightly']['hour'],
            minute=proj['nightly']['minute'],
            # - always run this job (even if no changes have been committed
            #   since the last run)
            onlyIfChanged=False,
            properties={'use_latest': True}
        )
        c['schedulers'].append(nightly)

        onpush = schedulers.AnyBranchScheduler(
            name="%s.%s/onpush" % (proj['name'], pipeline['name']),
            change_filter=util.ChangeFilter(
                project=proj['name'],
                repository_re=".*",
                branch_re=".*",
            ),
            treeStableTimer=None,
            builderNames=[bldr_name],
        )
        c['schedulers'].append(onpush)

        ondemand= schedulers.ForceScheduler(
            name="%s.%s/ondemand" % (proj['name'], pipeline['name']),
            builderNames=[bldr_name],
            repository=util.ChoiceStringParameter(
                name="repository", required=True,
                choices=[proj['repo']], default=proj['repo']
            ),
            branch=util.StringParameter(
                name="branch", required=True, default="master"
            ),
            project=util.FixedParameter(name="project", default=""),
            revision=util.FixedParameter(name="revision", default=""),
            properties=[]
        )
        c['schedulers'].append(ondemand)

####### BUILD FACTORIES

# A build factory defines the set of steps to perform for a particular build
# type.

@util.renderer
def get_repo_url_from_build_request(props):
    # - the standard "repository" build property looks something like this:
    #   "git@172.28.128.102:velcro/foo.git"
    # - but the "repourl" value that we want to pass to the Git build step
    #   looks something like this: "ssh://git@172.28.128.102/velcro/foo.git"
    #   (ie. "ssh://" prefix is added and ":" before the namespace is replaced
    #   with "/")
    repo = props.getProperty("repository")
    if repo.startswith("git@"):
        baseurl, repopath = repo.split(":")
        return "ssh://%s/%s" % (baseurl, repopath)
    else:
        return repo

@util.renderer
def get_systest_cmd(props):
    stage = props.getProperty("stage")
    orchestration = props.getProperty("orchestration")
    return "make %s orchestration=%s" % (stage, orchestration)

# - derive cloneable repo url from build request's repo url
normalize_repo = steps.SetProperty(
    name="normalize repo url",
    description=["normalizing repo url"],
    descriptionDone=["normalize repo url"],
    haltOnFailure=True,
    property="repo.url",
    value=get_repo_url_from_build_request
)
clone_repo = steps.Git(
    name="clone repo",
    description=["cloning repo ..."],
    descriptionDone=["clone repo"],
    haltOnFailure=True,
    logEnviron=False,
    alwaysUseLatest=util.Property("use_latest", default=False),
    repourl=util.Property("repo.url"),
    branch=util.Property("branch", default="master"),
    # - "full + clobber" => remove build directory and make a full clone
    #   from the target repo
    mode="full",
    method="clobber",
    # - incorporate/allow git submodules
    submodules=True,
)
run_functest = steps.ShellCommand(
    name="func test",
    description=["running func tests ..."],
    descriptionDone=["run func tests"],
    haltOnFailure=False,
    logEnviron=False,
    command=get_systest_cmd,
    workdir="build/systest",
)
run_scaletest = steps.ShellCommand(
    name="scale test",
    description=["running scale tests ..."],
    descriptionDone=["run scale tests"],
    haltOnFailure=False,
    logEnviron=False,
    command=get_systest_cmd,
    workdir="build/systest",
)
run_perftest = steps.ShellCommand(
    name="perf test",
    description=["running perf tests ..."],
    descriptionDone=["run perf tests"],
    haltOnFailure=False,
    logEnviron=False,
    command=get_systest_cmd,
    workdir="build/systest",
)
# - copy test results to nfs results dir
download_results = steps.ShellCommand(
    name="download results",
    description=["downloading results ..."],
    descriptionDone=["download results"],
    haltOnFailure=False,
    logEnviron=False,
    command="cp -R -p test_results/* ~/test_results/",
    workdir="build/systest",
)

functest_factory = util.BuildFactory()
functest_factory.addStep(normalize_repo)
functest_factory.addStep(clone_repo)
functest_factory.addStep(run_functest)
functest_factory.addStep(download_results)

scaletest_factory = util.BuildFactory()
scaletest_factory.addStep(normalize_repo)
scaletest_factory.addStep(clone_repo)
scaletest_factory.addStep(run_scaletest)
scaletest_factory.addStep(download_results)

perftest_factory = util.BuildFactory()
perftest_factory.addStep(normalize_repo)
perftest_factory.addStep(clone_repo)
perftest_factory.addStep(run_perftest)
perftest_factory.addStep(download_results)

build_factories['functest'] = functest_factory
build_factories['scaletest'] = scaletest_factory
build_factories['perftest'] = perftest_factory

####### BUILDERS

# The 'builders' list defines the Builders, which tell Buildbot how to perform a build:
# what steps, and which workers can execute them.  Note that any particular build will
# only take place on one worker.

c['builders'] = []

# - each member of build_factories represents a valid pipeline stage
# - each pipeline stage is implemented as a triggerable scheduler
# - each triggerable scheduler requires an associated builder
# - each builder requires an associated build factory and build worker(s)

for bldr_name, bf in build_factories.iteritems():
    # - add a builder for each pipeline stage
    bldr_dir = "builders/%s" % bldr_name
    builder = util.BuilderConfig(
        name=bldr_name,
        slavenames=default_workers,
        factory=bf,
        # - builddir is a directory on the master (relative to the master's
        #   basedir that will store artifacts (eg. build logs) related to this
        #   builder
        builddir=bldr_dir,
        # - slavebuilddir is a directory on the worker (relative to the
        #   worker's basedir) where the build is performed (ie. this is where
        #   checkouts, compiles and tests are run)
        slavebuilddir=bldr_dir,
        properties={'stage': bldr_name}
    )
    c['builders'].append(builder)

    # - add a triggerable scheduler for each pipeline stage
    scheduler = schedulers.Triggerable(
        name=bldr_name, builderNames=[bldr_name]
    )
    c['schedulers'].append(scheduler)

def get_stage_step(stage):
    if stage.lower().startswith("setprop"):
        parts = re.sub(r'\s{2,}', " ", stage).split(" ")
        prop_name = parts[1]
        prop_val = parts[2]
        return steps.SetProperty(
            name=stage,
            description=["setting %s ..." % prop_name],
            descriptionDone=["set %s" % prop_name, "to '%s'" % prop_val],
            haltOnFailure=True,
            property=prop_name,
            value=prop_val
        )
    else:
        return steps.Trigger(
            name=stage,
            description=["running %s stage" % stage],
            descriptionDone=[stage],
            haltOnFailure=False,
            schedulerNames=[stage],
            waitForFinish=True,
            sourceStamp={
                'repository': util.Property("repository"),
                'branch': util.Property("branch"),
            },
            # - copy standard properties into the triggered scheduler
            set_properties={
                'use_latest': util.Property("use_latest", False),
                'orchestration': util.Property("orchestration", None)
            }
        )

# - add the pipeline builders
pipeline_idx = 0
for project in projects:
    for pipeline in project['pipelines']:
        pipeline_idx += 1
        # - create the buildfactory for this pipeline
        bf = util.BuildFactory()
        for stage in pipeline['stages']:
            bf.addStep(get_stage_step(stage))
        # - add the builder that represents this pipeline
        # - the choice of worker names here is arbitrary, because the value
        #   provided won't actually be used (since the buildfactory directs
        #   control to a series of triggerable schedulers, each of which has
        #   their own set of workers)
        bldr_name = get_pipeline_builder_name(
            project['name'], pipeline['name'], pipeline_idx
        )
        bldr_dir = "builders/%s" % bldr_name
        bldr = util.BuilderConfig(
            name=bldr_name,
            slavenames=default_workers,
            factory=bf,
            builddir=bldr_dir,
            slavebuilddir=bldr_dir
        )
        c['builders'].append(bldr)

####### STATUS TARGETS

# 'status' is a list of Status Targets. The results of each build will be
# pushed to these targets. buildbot/status/*.py has a variety to choose from,
# including web pages, email senders, and IRC bots.

c['status'] = []

from buildbot.status import html
from buildbot.status.web import authz, auth

authz_cfg=authz.Authz(
    # change any of these to True to enable; see the manual for more
    # options
    auth=auth.BasicAuth(
        [(os.environ['BBOT_UI_USER'], os.environ['BBOT_UI_PASS'])]
    ),
    forceBuild="auth",
    forceAllBuilds="auth",
    pingBuilder="auth",
    gracefulShutdown="auth",
    pauseSlave="auth",
    stopBuild="auth",
    stopAllBuilds="auth",
    cancelPendingBuild="auth",
    cancelAllPendingBuilds="auth",
    stopChange="auth",
    cleanShutdown="auth",
    showUsersPage="auth",
)
c['status'].append(
    html.WebStatus(
        http_port=os.environ['BBOT_UI_PORT'],
        authz=authz_cfg,
        # - enable gitlab webhooks
        change_hook_dialects={'gitlab': True},
        # - set webhook auth credentials
        change_hook_auth=["file:changehook.passwd"]
    )
)

####### PROJECT IDENTITY

# the 'title' string will appear at the top of this buildbot
# installation's html.WebStatus home page (linked to the
# 'titleURL') and is embedded in the title of the waterfall HTML page.

c['title'] = "velcro"
c['titleURL'] = ""

# the 'buildbotURL' string should point to the location where the buildbot's
# internal web server (usually the html.WebStatus page) is visible. This
# typically uses the port number set in the Waterfall 'status' entry, but
# with an externally-visible host name which the buildbot cannot figure out
# without some help.

# - this value should end with a "/"
c['buildbotURL'] = os.environ['BBOT_ROOT_URL']

####### DB URL

c['db'] = {
    # This specifies what database buildbot uses to store its state.  You can leave
    # this at its default for all but the largest installations.
    'db_url' : "sqlite:///state.sqlite",
}
